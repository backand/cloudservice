<section class="" style="width: 650px;">
  <div class="panel panel-default">
    <div class="panel-heading"><strong>Model Definition with JSON</strong></div>
    <div class="panel-body">
      <h4><u>Example</u></h4>
<pre><code>[
  {
    "name": "tasks",
    "fields": {
      "description": {
        "type": "string"
      },
      "completed": {
        "type": "boolean"
      },
      "members": {
        "collection": "members",
        "via": "task"
      }
    }
  },
  {
    "name": "members",
    "fields": {
      "name": {
        "type": "string"
      },
      "task": {
        "object": "tasks"
      }
    }
  }
]
</code></pre>
      <h4><u>Clarifications</u></h4>
      <h5>
        - In addition to the fields supplied by the user, Backand defines an 'id' field, of type integer, which will be used as a primary key for the table.<br/>
      </h5>
      <h5>
        - Renaming fields can only be done from the Fields tab in the application dashboard. Renaming a field or an object in a model will delete the data associated with that field or object.
      </h5>
      <br/>
      <h4><u>Definitions</u></h4>
        <h5>
          The model represent a database schema that is defined as a JSON array of one or more object (Table) definitions:
        </h5>
<pre><code>&lt;model&gt; = [  &lt;object&gt;, &lt;object&gt;, ... ]</code></pre>
        <h5>
          An object definition is a JSON object with a name entry and a fields entry:
        </h5>
<pre><code>&lt;object&gt; = { "name":  &lt;string&gt;, "fields" : &lt;fields&gt; }</code></pre>
        <h5>
          The fields definition is a JSON list of field attributes:
        </h5>
<pre><code>&lt;fields&gt; =  { "field1" : &lt;field&gt;, "field2": &lt;field&gt;, ... }</code></pre>
        <h5>
          A field is defined by its type and a set of optional properties. The field definition is a JSON object:
        </h5>
<pre><code>&lt;field&gt; = { "type": &lt;type&gt;, &lt;optional properties&gt;}</code></pre>
        <h5>
          A field may have one of the following types:<br/>
          <ul>
            <li>string - string column up to 255 characters</li>
            <li>text - text column up to 21,844 characters</li>
            <li>float</li>
            <li>datetime</li>
            <li>boolean</li>
          </ul>
        </h5>
        <h5>
            We can optionally defined a field as required (`NOT NULL`) or not:
        </h5>
<pre><code>"required": &lt;boolean value&gt;</pre></code>
        <h5>
            Where a boolean value is true or false.
        </h5>
        <h5>
            And set its default value:
        </h5>
<pre><code>"defaultValue": &lt;value&gt;</pre></code>
        <h5>
          Where `&lt;value&gt;` is of the type of the field.
        </h5>
        <br/>
        <h4><u>One-to-Many Relationship</u></h4>
        <h5>
          One-to-many relationship between tables are specified using relationship fields. A relationship field will generate the appropriate foreign-key relationship fields in the corresponding relation objects<br/><br/>
          Say, for example, that we have a one to many relationship between tables R and S. This means that for each row in R, there are many potentially corresponding rows in S.<br/><br/>
          In the 'many' side of the relationship (object S), we specify that each row relates to one row in the other object R by providing an object field link:
        </h5>
<pre><code>"myR" : { "object" : "R" }</pre></code>
        <h5>
          In the 'one' side of the relationship (object R), we specify that each row relates to several rows in S by providing a 'collection' field link, using a 'via' attribute to denote which field on the 'many' side (object S) fulfills the relationship:
        </h5>
<pre><code>"Rs" : { "collection": "S", "via" : "myR" }</pre></code>
        <h5>
          As an example, consider a database describing pet ownership. It has two tables, `person` and `pet`. Each person can own several pets, but a pet has a single owner. Thus, the person-pet relationship is a one to many relationship between person and pet:<br/>
          <br/>
          The 'person' object will have a 'pets' a relationship field, which establishes the 'one' side of the relationship by creating a collection of pet objects for each person in the database:
        </h5>
<pre><code>"pets": { "collection": "pet", "via": "owner" }</pre></code>
        <h5>
          The 'pet' table will have an 'owner' a relationship field, which establishes the 'many' side of the relationship by linking each pet back to an individual owner instance of type 'person':
        </h5>
<pre><code>"owner": { "object": "person" }</pre></code>
        <br/>
        <br/>

    </div>
  </div>
</section>
